// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: OraProtoBuf.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_OraProtoBuf_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_OraProtoBuf_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_OraProtoBuf_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_OraProtoBuf_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_OraProtoBuf_2eproto;
namespace OpenLogReplicator {
namespace pb {
class Column;
struct ColumnDefaultTypeInternal;
extern ColumnDefaultTypeInternal _Column_default_instance_;
class Payload;
struct PayloadDefaultTypeInternal;
extern PayloadDefaultTypeInternal _Payload_default_instance_;
class RedoRequest;
struct RedoRequestDefaultTypeInternal;
extern RedoRequestDefaultTypeInternal _RedoRequest_default_instance_;
class RedoResponse;
struct RedoResponseDefaultTypeInternal;
extern RedoResponseDefaultTypeInternal _RedoResponse_default_instance_;
class RedoResponse_AttributesEntry_DoNotUse;
struct RedoResponse_AttributesEntry_DoNotUseDefaultTypeInternal;
extern RedoResponse_AttributesEntry_DoNotUseDefaultTypeInternal _RedoResponse_AttributesEntry_DoNotUse_default_instance_;
class Schema;
struct SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class SchemaRequest;
struct SchemaRequestDefaultTypeInternal;
extern SchemaRequestDefaultTypeInternal _SchemaRequest_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
}  // namespace pb
}  // namespace OpenLogReplicator
PROTOBUF_NAMESPACE_OPEN
template<> ::OpenLogReplicator::pb::Column* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::Column>(Arena*);
template<> ::OpenLogReplicator::pb::Payload* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::Payload>(Arena*);
template<> ::OpenLogReplicator::pb::RedoRequest* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::RedoRequest>(Arena*);
template<> ::OpenLogReplicator::pb::RedoResponse* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::RedoResponse>(Arena*);
template<> ::OpenLogReplicator::pb::RedoResponse_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::RedoResponse_AttributesEntry_DoNotUse>(Arena*);
template<> ::OpenLogReplicator::pb::Schema* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::Schema>(Arena*);
template<> ::OpenLogReplicator::pb::SchemaRequest* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::SchemaRequest>(Arena*);
template<> ::OpenLogReplicator::pb::Value* Arena::CreateMaybeMessage<::OpenLogReplicator::pb::Value>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace OpenLogReplicator {
namespace pb {

enum Op : int {
  BEGIN = 0,
  COMMIT = 1,
  INSERT = 2,
  UPDATE = 3,
  DELETE = 4,
  DDL = 5,
  CHKPT = 6,
  Op_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Op_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Op_IsValid(int value);
constexpr Op Op_MIN = BEGIN;
constexpr Op Op_MAX = CHKPT;
constexpr int Op_ARRAYSIZE = Op_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Op_descriptor();
template<typename T>
inline const std::string& Op_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Op>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Op_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Op_descriptor(), enum_t_value);
}
inline bool Op_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Op* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Op>(
    Op_descriptor(), name, value);
}
enum ColumnType : int {
  UNKNOWN = 0,
  VARCHAR2 = 1,
  NUMBER = 2,
  LONG = 3,
  DATE = 4,
  RAW = 5,
  LONG_RAW = 6,
  CHAR = 7,
  BINARY_FLOAT = 8,
  BINARY_DOUBLE = 9,
  CLOB = 10,
  BLOB = 11,
  TIMESTAMP = 12,
  TIMESTAMP_WITH_TZ = 13,
  INTERVAL_YEAR_TO_MONTH = 14,
  INTERVAL_DAY_TO_SECOND = 15,
  UROWID = 16,
  TIMESTAMP_WITH_LOCAL_TZ = 17,
  ColumnType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ColumnType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ColumnType_IsValid(int value);
constexpr ColumnType ColumnType_MIN = UNKNOWN;
constexpr ColumnType ColumnType_MAX = TIMESTAMP_WITH_LOCAL_TZ;
constexpr int ColumnType_ARRAYSIZE = ColumnType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ColumnType_descriptor();
template<typename T>
inline const std::string& ColumnType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ColumnType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ColumnType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ColumnType_descriptor(), enum_t_value);
}
inline bool ColumnType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ColumnType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ColumnType>(
    ColumnType_descriptor(), name, value);
}
enum RequestCode : int {
  INFO = 0,
  START = 1,
  CONTINUE = 2,
  CONFIRM = 3,
  RequestCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RequestCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RequestCode_IsValid(int value);
constexpr RequestCode RequestCode_MIN = INFO;
constexpr RequestCode RequestCode_MAX = CONFIRM;
constexpr int RequestCode_ARRAYSIZE = RequestCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestCode_descriptor();
template<typename T>
inline const std::string& RequestCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestCode_descriptor(), enum_t_value);
}
inline bool RequestCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestCode>(
    RequestCode_descriptor(), name, value);
}
enum ResponseCode : int {
  READY = 0,
  FAILED_START = 1,
  STARTING = 2,
  ALREADY_STARTED = 3,
  REPLICATE = 4,
  PAYLOAD = 5,
  INVALID_DATABASE = 6,
  INVALID_COMMAND = 7,
  ResponseCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ResponseCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ResponseCode_IsValid(int value);
constexpr ResponseCode ResponseCode_MIN = READY;
constexpr ResponseCode ResponseCode_MAX = INVALID_COMMAND;
constexpr int ResponseCode_ARRAYSIZE = ResponseCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseCode_descriptor();
template<typename T>
inline const std::string& ResponseCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseCode_descriptor(), enum_t_value);
}
inline bool ResponseCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseCode>(
    ResponseCode_descriptor(), name, value);
}
// ===================================================================

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit PROTOBUF_CONSTEXPR Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum DatumCase {
    kValueInt = 2,
    kValueFloat = 3,
    kValueDouble = 4,
    kValueString = 5,
    kValueBytes = 6,
    DATUM_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Value& from) {
    Value::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueIntFieldNumber = 2,
    kValueFloatFieldNumber = 3,
    kValueDoubleFieldNumber = 4,
    kValueStringFieldNumber = 5,
    kValueBytesFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 value_int = 2;
  bool has_value_int() const;
  private:
  bool _internal_has_value_int() const;
  public:
  void clear_value_int();
  int64_t value_int() const;
  void set_value_int(int64_t value);
  private:
  int64_t _internal_value_int() const;
  void _internal_set_value_int(int64_t value);
  public:

  // float value_float = 3;
  bool has_value_float() const;
  private:
  bool _internal_has_value_float() const;
  public:
  void clear_value_float();
  float value_float() const;
  void set_value_float(float value);
  private:
  float _internal_value_float() const;
  void _internal_set_value_float(float value);
  public:

  // double value_double = 4;
  bool has_value_double() const;
  private:
  bool _internal_has_value_double() const;
  public:
  void clear_value_double();
  double value_double() const;
  void set_value_double(double value);
  private:
  double _internal_value_double() const;
  void _internal_set_value_double(double value);
  public:

  // string value_string = 5;
  bool has_value_string() const;
  private:
  bool _internal_has_value_string() const;
  public:
  void clear_value_string();
  const std::string& value_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_string();
  PROTOBUF_NODISCARD std::string* release_value_string();
  void set_allocated_value_string(std::string* value_string);
  private:
  const std::string& _internal_value_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_string(const std::string& value);
  std::string* _internal_mutable_value_string();
  public:

  // bytes value_bytes = 6;
  bool has_value_bytes() const;
  private:
  bool _internal_has_value_bytes() const;
  public:
  void clear_value_bytes();
  const std::string& value_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_bytes();
  PROTOBUF_NODISCARD std::string* release_value_bytes();
  void set_allocated_value_bytes(std::string* value_bytes);
  private:
  const std::string& _internal_value_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_bytes(const std::string& value);
  std::string* _internal_mutable_value_bytes();
  public:

  void clear_datum();
  DatumCase datum_case() const;
  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.Value)
 private:
  class _Internal;
  void set_has_value_int();
  void set_has_value_float();
  void set_has_value_double();
  void set_has_value_string();
  void set_has_value_bytes();

  inline bool has_datum() const;
  inline void clear_has_datum();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    union DatumUnion {
      constexpr DatumUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int64_t value_int_;
      float value_float_;
      double value_double_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_string_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_bytes_;
    } datum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// -------------------------------------------------------------------

class Column final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.Column) */ {
 public:
  inline Column() : Column(nullptr) {}
  ~Column() override;
  explicit PROTOBUF_CONSTEXPR Column(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Column(const Column& from);
  Column(Column&& from) noexcept
    : Column() {
    *this = ::std::move(from);
  }

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }
  inline Column& operator=(Column&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Column& default_instance() {
    return *internal_default_instance();
  }
  static inline const Column* internal_default_instance() {
    return reinterpret_cast<const Column*>(
               &_Column_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Column& a, Column& b) {
    a.Swap(&b);
  }
  inline void Swap(Column* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Column* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Column* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Column>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Column& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Column& from) {
    Column::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Column* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.Column";
  }
  protected:
  explicit Column(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kLengthFieldNumber = 3,
    kPrecisionFieldNumber = 4,
    kScaleFieldNumber = 5,
    kNullableFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .OpenLogReplicator.pb.ColumnType type = 2;
  void clear_type();
  ::OpenLogReplicator::pb::ColumnType type() const;
  void set_type(::OpenLogReplicator::pb::ColumnType value);
  private:
  ::OpenLogReplicator::pb::ColumnType _internal_type() const;
  void _internal_set_type(::OpenLogReplicator::pb::ColumnType value);
  public:

  // int32 length = 3;
  void clear_length();
  int32_t length() const;
  void set_length(int32_t value);
  private:
  int32_t _internal_length() const;
  void _internal_set_length(int32_t value);
  public:

  // int32 precision = 4;
  void clear_precision();
  int32_t precision() const;
  void set_precision(int32_t value);
  private:
  int32_t _internal_precision() const;
  void _internal_set_precision(int32_t value);
  public:

  // int32 scale = 5;
  void clear_scale();
  int32_t scale() const;
  void set_scale(int32_t value);
  private:
  int32_t _internal_scale() const;
  void _internal_set_scale(int32_t value);
  public:

  // bool nullable = 6;
  void clear_nullable();
  bool nullable() const;
  void set_nullable(bool value);
  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.Column)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int type_;
    int32_t length_;
    int32_t precision_;
    int32_t scale_;
    bool nullable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// -------------------------------------------------------------------

class Schema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.Schema) */ {
 public:
  inline Schema() : Schema(nullptr) {}
  ~Schema() override;
  explicit PROTOBUF_CONSTEXPR Schema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Schema(const Schema& from);
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  inline Schema& operator=(Schema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Schema& default_instance() {
    return *internal_default_instance();
  }
  enum TmValCase {
    kTm = 4,
    kTms = 5,
    TM_VAL_NOT_SET = 0,
  };

  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }
  inline void Swap(Schema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Schema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Schema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Schema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Schema& from) {
    Schema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.Schema";
  }
  protected:
  explicit Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFieldNumber = 6,
    kOwnerFieldNumber = 1,
    kNameFieldNumber = 2,
    kObjFieldNumber = 3,
    kTmFieldNumber = 4,
    kTmsFieldNumber = 5,
  };
  // repeated .OpenLogReplicator.pb.Column column = 6;
  int column_size() const;
  private:
  int _internal_column_size() const;
  public:
  void clear_column();
  ::OpenLogReplicator::pb::Column* mutable_column(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Column >*
      mutable_column();
  private:
  const ::OpenLogReplicator::pb::Column& _internal_column(int index) const;
  ::OpenLogReplicator::pb::Column* _internal_add_column();
  public:
  const ::OpenLogReplicator::pb::Column& column(int index) const;
  ::OpenLogReplicator::pb::Column* add_column();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Column >&
      column() const;

  // string owner = 1;
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 obj = 3;
  void clear_obj();
  uint32_t obj() const;
  void set_obj(uint32_t value);
  private:
  uint32_t _internal_obj() const;
  void _internal_set_obj(uint32_t value);
  public:

  // uint64 tm = 4;
  bool has_tm() const;
  private:
  bool _internal_has_tm() const;
  public:
  void clear_tm();
  uint64_t tm() const;
  void set_tm(uint64_t value);
  private:
  uint64_t _internal_tm() const;
  void _internal_set_tm(uint64_t value);
  public:

  // string tms = 5;
  bool has_tms() const;
  private:
  bool _internal_has_tms() const;
  public:
  void clear_tms();
  const std::string& tms() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tms(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tms();
  PROTOBUF_NODISCARD std::string* release_tms();
  void set_allocated_tms(std::string* tms);
  private:
  const std::string& _internal_tms() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tms(const std::string& value);
  std::string* _internal_mutable_tms();
  public:

  void clear_tm_val();
  TmValCase tm_val_case() const;
  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.Schema)
 private:
  class _Internal;
  void set_has_tm();
  void set_has_tms();

  inline bool has_tm_val() const;
  inline void clear_has_tm_val();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Column > column_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t obj_;
    union TmValUnion {
      constexpr TmValUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t tm_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tms_;
    } tm_val_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// -------------------------------------------------------------------

class Payload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.Payload) */ {
 public:
  inline Payload() : Payload(nullptr) {}
  ~Payload() override;
  explicit PROTOBUF_CONSTEXPR Payload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Payload(const Payload& from);
  Payload(Payload&& from) noexcept
    : Payload() {
    *this = ::std::move(from);
  }

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payload& operator=(Payload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Payload& default_instance() {
    return *internal_default_instance();
  }
  static inline const Payload* internal_default_instance() {
    return reinterpret_cast<const Payload*>(
               &_Payload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Payload& a, Payload& b) {
    a.Swap(&b);
  }
  inline void Swap(Payload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Payload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Payload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Payload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Payload& from) {
    Payload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.Payload";
  }
  protected:
  explicit Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeforeFieldNumber = 4,
    kAfterFieldNumber = 5,
    kRidFieldNumber = 3,
    kDdlFieldNumber = 6,
    kSchemaFieldNumber = 2,
    kOpFieldNumber = 1,
    kSeqFieldNumber = 7,
    kOffsetFieldNumber = 8,
    kNumFieldNumber = 10,
    kRedoFieldNumber = 9,
  };
  // repeated .OpenLogReplicator.pb.Value before = 4;
  int before_size() const;
  private:
  int _internal_before_size() const;
  public:
  void clear_before();
  ::OpenLogReplicator::pb::Value* mutable_before(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >*
      mutable_before();
  private:
  const ::OpenLogReplicator::pb::Value& _internal_before(int index) const;
  ::OpenLogReplicator::pb::Value* _internal_add_before();
  public:
  const ::OpenLogReplicator::pb::Value& before(int index) const;
  ::OpenLogReplicator::pb::Value* add_before();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >&
      before() const;

  // repeated .OpenLogReplicator.pb.Value after = 5;
  int after_size() const;
  private:
  int _internal_after_size() const;
  public:
  void clear_after();
  ::OpenLogReplicator::pb::Value* mutable_after(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >*
      mutable_after();
  private:
  const ::OpenLogReplicator::pb::Value& _internal_after(int index) const;
  ::OpenLogReplicator::pb::Value* _internal_add_after();
  public:
  const ::OpenLogReplicator::pb::Value& after(int index) const;
  ::OpenLogReplicator::pb::Value* add_after();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >&
      after() const;

  // string rid = 3;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string ddl = 6;
  void clear_ddl();
  const std::string& ddl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ddl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ddl();
  PROTOBUF_NODISCARD std::string* release_ddl();
  void set_allocated_ddl(std::string* ddl);
  private:
  const std::string& _internal_ddl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ddl(const std::string& value);
  std::string* _internal_mutable_ddl();
  public:

  // .OpenLogReplicator.pb.Schema schema = 2;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::OpenLogReplicator::pb::Schema& schema() const;
  PROTOBUF_NODISCARD ::OpenLogReplicator::pb::Schema* release_schema();
  ::OpenLogReplicator::pb::Schema* mutable_schema();
  void set_allocated_schema(::OpenLogReplicator::pb::Schema* schema);
  private:
  const ::OpenLogReplicator::pb::Schema& _internal_schema() const;
  ::OpenLogReplicator::pb::Schema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::OpenLogReplicator::pb::Schema* schema);
  ::OpenLogReplicator::pb::Schema* unsafe_arena_release_schema();

  // .OpenLogReplicator.pb.Op op = 1;
  void clear_op();
  ::OpenLogReplicator::pb::Op op() const;
  void set_op(::OpenLogReplicator::pb::Op value);
  private:
  ::OpenLogReplicator::pb::Op _internal_op() const;
  void _internal_set_op(::OpenLogReplicator::pb::Op value);
  public:

  // uint32 seq = 7;
  void clear_seq();
  uint32_t seq() const;
  void set_seq(uint32_t value);
  private:
  uint32_t _internal_seq() const;
  void _internal_set_seq(uint32_t value);
  public:

  // uint64 offset = 8;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint64 num = 10;
  void clear_num();
  uint64_t num() const;
  void set_num(uint64_t value);
  private:
  uint64_t _internal_num() const;
  void _internal_set_num(uint64_t value);
  public:

  // bool redo = 9;
  void clear_redo();
  bool redo() const;
  void set_redo(bool value);
  private:
  bool _internal_redo() const;
  void _internal_set_redo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.Payload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value > before_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value > after_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ddl_;
    ::OpenLogReplicator::pb::Schema* schema_;
    int op_;
    uint32_t seq_;
    uint64_t offset_;
    uint64_t num_;
    bool redo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// -------------------------------------------------------------------

class SchemaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.SchemaRequest) */ {
 public:
  inline SchemaRequest() : SchemaRequest(nullptr) {}
  ~SchemaRequest() override;
  explicit PROTOBUF_CONSTEXPR SchemaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaRequest(const SchemaRequest& from);
  SchemaRequest(SchemaRequest&& from) noexcept
    : SchemaRequest() {
    *this = ::std::move(from);
  }

  inline SchemaRequest& operator=(const SchemaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaRequest& operator=(SchemaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaRequest* internal_default_instance() {
    return reinterpret_cast<const SchemaRequest*>(
               &_SchemaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SchemaRequest& a, SchemaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchemaRequest& from) {
    SchemaRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.SchemaRequest";
  }
  protected:
  explicit SchemaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaskFieldNumber = 1,
    kFilterFieldNumber = 2,
  };
  // string mask = 1;
  void clear_mask();
  const std::string& mask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mask();
  PROTOBUF_NODISCARD std::string* release_mask();
  void set_allocated_mask(std::string* mask);
  private:
  const std::string& _internal_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mask(const std::string& value);
  std::string* _internal_mutable_mask();
  public:

  // string filter = 2;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.SchemaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mask_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// -------------------------------------------------------------------

class RedoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.RedoRequest) */ {
 public:
  inline RedoRequest() : RedoRequest(nullptr) {}
  ~RedoRequest() override;
  explicit PROTOBUF_CONSTEXPR RedoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedoRequest(const RedoRequest& from);
  RedoRequest(RedoRequest&& from) noexcept
    : RedoRequest() {
    *this = ::std::move(from);
  }

  inline RedoRequest& operator=(const RedoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedoRequest& operator=(RedoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedoRequest& default_instance() {
    return *internal_default_instance();
  }
  enum TmValCase {
    kScn = 3,
    kTms = 4,
    kTmRel = 5,
    TM_VAL_NOT_SET = 0,
  };

  static inline const RedoRequest* internal_default_instance() {
    return reinterpret_cast<const RedoRequest*>(
               &_RedoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RedoRequest& a, RedoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RedoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RedoRequest& from) {
    RedoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.RedoRequest";
  }
  protected:
  explicit RedoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 7,
    kDatabaseNameFieldNumber = 2,
    kSeqFieldNumber = 6,
    kCScnFieldNumber = 8,
    kCIdxFieldNumber = 9,
    kCodeFieldNumber = 1,
    kScnFieldNumber = 3,
    kTmsFieldNumber = 4,
    kTmRelFieldNumber = 5,
  };
  // repeated .OpenLogReplicator.pb.SchemaRequest schema = 7;
  int schema_size() const;
  private:
  int _internal_schema_size() const;
  public:
  void clear_schema();
  ::OpenLogReplicator::pb::SchemaRequest* mutable_schema(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::SchemaRequest >*
      mutable_schema();
  private:
  const ::OpenLogReplicator::pb::SchemaRequest& _internal_schema(int index) const;
  ::OpenLogReplicator::pb::SchemaRequest* _internal_add_schema();
  public:
  const ::OpenLogReplicator::pb::SchemaRequest& schema(int index) const;
  ::OpenLogReplicator::pb::SchemaRequest* add_schema();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::SchemaRequest >&
      schema() const;

  // string database_name = 2;
  void clear_database_name();
  const std::string& database_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database_name();
  PROTOBUF_NODISCARD std::string* release_database_name();
  void set_allocated_database_name(std::string* database_name);
  private:
  const std::string& _internal_database_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database_name(const std::string& value);
  std::string* _internal_mutable_database_name();
  public:

  // optional uint64 seq = 6;
  bool has_seq() const;
  private:
  bool _internal_has_seq() const;
  public:
  void clear_seq();
  uint64_t seq() const;
  void set_seq(uint64_t value);
  private:
  uint64_t _internal_seq() const;
  void _internal_set_seq(uint64_t value);
  public:

  // optional uint64 c_scn = 8;
  bool has_c_scn() const;
  private:
  bool _internal_has_c_scn() const;
  public:
  void clear_c_scn();
  uint64_t c_scn() const;
  void set_c_scn(uint64_t value);
  private:
  uint64_t _internal_c_scn() const;
  void _internal_set_c_scn(uint64_t value);
  public:

  // optional uint64 c_idx = 9;
  bool has_c_idx() const;
  private:
  bool _internal_has_c_idx() const;
  public:
  void clear_c_idx();
  uint64_t c_idx() const;
  void set_c_idx(uint64_t value);
  private:
  uint64_t _internal_c_idx() const;
  void _internal_set_c_idx(uint64_t value);
  public:

  // .OpenLogReplicator.pb.RequestCode code = 1;
  void clear_code();
  ::OpenLogReplicator::pb::RequestCode code() const;
  void set_code(::OpenLogReplicator::pb::RequestCode value);
  private:
  ::OpenLogReplicator::pb::RequestCode _internal_code() const;
  void _internal_set_code(::OpenLogReplicator::pb::RequestCode value);
  public:

  // uint64 scn = 3;
  bool has_scn() const;
  private:
  bool _internal_has_scn() const;
  public:
  void clear_scn();
  uint64_t scn() const;
  void set_scn(uint64_t value);
  private:
  uint64_t _internal_scn() const;
  void _internal_set_scn(uint64_t value);
  public:

  // string tms = 4;
  bool has_tms() const;
  private:
  bool _internal_has_tms() const;
  public:
  void clear_tms();
  const std::string& tms() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tms(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tms();
  PROTOBUF_NODISCARD std::string* release_tms();
  void set_allocated_tms(std::string* tms);
  private:
  const std::string& _internal_tms() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tms(const std::string& value);
  std::string* _internal_mutable_tms();
  public:

  // int64 tm_rel = 5;
  bool has_tm_rel() const;
  private:
  bool _internal_has_tm_rel() const;
  public:
  void clear_tm_rel();
  int64_t tm_rel() const;
  void set_tm_rel(int64_t value);
  private:
  int64_t _internal_tm_rel() const;
  void _internal_set_tm_rel(int64_t value);
  public:

  void clear_tm_val();
  TmValCase tm_val_case() const;
  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.RedoRequest)
 private:
  class _Internal;
  void set_has_scn();
  void set_has_tms();
  void set_has_tm_rel();

  inline bool has_tm_val() const;
  inline void clear_has_tm_val();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::SchemaRequest > schema_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_name_;
    uint64_t seq_;
    uint64_t c_scn_;
    uint64_t c_idx_;
    int code_;
    union TmValUnion {
      constexpr TmValUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t scn_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tms_;
      int64_t tm_rel_;
    } tm_val_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// -------------------------------------------------------------------

class RedoResponse_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RedoResponse_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RedoResponse_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RedoResponse_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RedoResponse_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RedoResponse_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RedoResponse_AttributesEntry_DoNotUse& other);
  static const RedoResponse_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RedoResponse_AttributesEntry_DoNotUse*>(&_RedoResponse_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "OpenLogReplicator.pb.RedoResponse.AttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "OpenLogReplicator.pb.RedoResponse.AttributesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_OraProtoBuf_2eproto;
};

// -------------------------------------------------------------------

class RedoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenLogReplicator.pb.RedoResponse) */ {
 public:
  inline RedoResponse() : RedoResponse(nullptr) {}
  ~RedoResponse() override;
  explicit PROTOBUF_CONSTEXPR RedoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedoResponse(const RedoResponse& from);
  RedoResponse(RedoResponse&& from) noexcept
    : RedoResponse() {
    *this = ::std::move(from);
  }

  inline RedoResponse& operator=(const RedoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedoResponse& operator=(RedoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedoResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ScnValCase {
    kScn = 2,
    kScns = 3,
    SCN_VAL_NOT_SET = 0,
  };

  enum TmValCase {
    kTm = 4,
    kTms = 5,
    TM_VAL_NOT_SET = 0,
  };

  enum XidValCase {
    kXid = 6,
    kXidn = 7,
    XID_VAL_NOT_SET = 0,
  };

  static inline const RedoResponse* internal_default_instance() {
    return reinterpret_cast<const RedoResponse*>(
               &_RedoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RedoResponse& a, RedoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RedoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RedoResponse& from) {
    RedoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenLogReplicator.pb.RedoResponse";
  }
  protected:
  explicit RedoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 9,
    kAttributesFieldNumber = 12,
    kDbFieldNumber = 8,
    kCScnFieldNumber = 10,
    kCIdxFieldNumber = 11,
    kCodeFieldNumber = 1,
    kScnFieldNumber = 2,
    kScnsFieldNumber = 3,
    kTmFieldNumber = 4,
    kTmsFieldNumber = 5,
    kXidFieldNumber = 6,
    kXidnFieldNumber = 7,
  };
  // repeated .OpenLogReplicator.pb.Payload payload = 9;
  int payload_size() const;
  private:
  int _internal_payload_size() const;
  public:
  void clear_payload();
  ::OpenLogReplicator::pb::Payload* mutable_payload(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Payload >*
      mutable_payload();
  private:
  const ::OpenLogReplicator::pb::Payload& _internal_payload(int index) const;
  ::OpenLogReplicator::pb::Payload* _internal_add_payload();
  public:
  const ::OpenLogReplicator::pb::Payload& payload(int index) const;
  ::OpenLogReplicator::pb::Payload* add_payload();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Payload >&
      payload() const;

  // map<string, string> attributes = 12;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attributes();

  // string db = 8;
  void clear_db();
  const std::string& db() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db();
  PROTOBUF_NODISCARD std::string* release_db();
  void set_allocated_db(std::string* db);
  private:
  const std::string& _internal_db() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db(const std::string& value);
  std::string* _internal_mutable_db();
  public:

  // uint64 c_scn = 10;
  void clear_c_scn();
  uint64_t c_scn() const;
  void set_c_scn(uint64_t value);
  private:
  uint64_t _internal_c_scn() const;
  void _internal_set_c_scn(uint64_t value);
  public:

  // uint64 c_idx = 11;
  void clear_c_idx();
  uint64_t c_idx() const;
  void set_c_idx(uint64_t value);
  private:
  uint64_t _internal_c_idx() const;
  void _internal_set_c_idx(uint64_t value);
  public:

  // .OpenLogReplicator.pb.ResponseCode code = 1;
  void clear_code();
  ::OpenLogReplicator::pb::ResponseCode code() const;
  void set_code(::OpenLogReplicator::pb::ResponseCode value);
  private:
  ::OpenLogReplicator::pb::ResponseCode _internal_code() const;
  void _internal_set_code(::OpenLogReplicator::pb::ResponseCode value);
  public:

  // uint64 scn = 2;
  bool has_scn() const;
  private:
  bool _internal_has_scn() const;
  public:
  void clear_scn();
  uint64_t scn() const;
  void set_scn(uint64_t value);
  private:
  uint64_t _internal_scn() const;
  void _internal_set_scn(uint64_t value);
  public:

  // string scns = 3;
  bool has_scns() const;
  private:
  bool _internal_has_scns() const;
  public:
  void clear_scns();
  const std::string& scns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scns();
  PROTOBUF_NODISCARD std::string* release_scns();
  void set_allocated_scns(std::string* scns);
  private:
  const std::string& _internal_scns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scns(const std::string& value);
  std::string* _internal_mutable_scns();
  public:

  // uint64 tm = 4;
  bool has_tm() const;
  private:
  bool _internal_has_tm() const;
  public:
  void clear_tm();
  uint64_t tm() const;
  void set_tm(uint64_t value);
  private:
  uint64_t _internal_tm() const;
  void _internal_set_tm(uint64_t value);
  public:

  // string tms = 5;
  bool has_tms() const;
  private:
  bool _internal_has_tms() const;
  public:
  void clear_tms();
  const std::string& tms() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tms(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tms();
  PROTOBUF_NODISCARD std::string* release_tms();
  void set_allocated_tms(std::string* tms);
  private:
  const std::string& _internal_tms() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tms(const std::string& value);
  std::string* _internal_mutable_tms();
  public:

  // string xid = 6;
  bool has_xid() const;
  private:
  bool _internal_has_xid() const;
  public:
  void clear_xid();
  const std::string& xid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xid();
  PROTOBUF_NODISCARD std::string* release_xid();
  void set_allocated_xid(std::string* xid);
  private:
  const std::string& _internal_xid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xid(const std::string& value);
  std::string* _internal_mutable_xid();
  public:

  // uint64 xidn = 7;
  bool has_xidn() const;
  private:
  bool _internal_has_xidn() const;
  public:
  void clear_xidn();
  uint64_t xidn() const;
  void set_xidn(uint64_t value);
  private:
  uint64_t _internal_xidn() const;
  void _internal_set_xidn(uint64_t value);
  public:

  void clear_scn_val();
  ScnValCase scn_val_case() const;
  void clear_tm_val();
  TmValCase tm_val_case() const;
  void clear_xid_val();
  XidValCase xid_val_case() const;
  // @@protoc_insertion_point(class_scope:OpenLogReplicator.pb.RedoResponse)
 private:
  class _Internal;
  void set_has_scn();
  void set_has_scns();
  void set_has_tm();
  void set_has_tms();
  void set_has_xid();
  void set_has_xidn();

  inline bool has_scn_val() const;
  inline void clear_has_scn_val();

  inline bool has_tm_val() const;
  inline void clear_has_tm_val();

  inline bool has_xid_val() const;
  inline void clear_has_xid_val();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Payload > payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RedoResponse_AttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_;
    uint64_t c_scn_;
    uint64_t c_idx_;
    int code_;
    union ScnValUnion {
      constexpr ScnValUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t scn_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scns_;
    } scn_val_;
    union TmValUnion {
      constexpr TmValUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t tm_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tms_;
    } tm_val_;
    union XidValUnion {
      constexpr XidValUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xid_;
      uint64_t xidn_;
    } xid_val_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[3];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OraProtoBuf_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Value

// string name = 1;
inline void Value::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Value::name() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Value.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Value::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.name)
}
inline std::string* Value::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Value.name)
  return _s;
}
inline const std::string& Value::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Value::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Value::release_name() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Value.name)
  return _impl_.name_.Release();
}
inline void Value::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Value.name)
}

// int64 value_int = 2;
inline bool Value::_internal_has_value_int() const {
  return datum_case() == kValueInt;
}
inline bool Value::has_value_int() const {
  return _internal_has_value_int();
}
inline void Value::set_has_value_int() {
  _impl_._oneof_case_[0] = kValueInt;
}
inline void Value::clear_value_int() {
  if (_internal_has_value_int()) {
    _impl_.datum_.value_int_ = int64_t{0};
    clear_has_datum();
  }
}
inline int64_t Value::_internal_value_int() const {
  if (_internal_has_value_int()) {
    return _impl_.datum_.value_int_;
  }
  return int64_t{0};
}
inline void Value::_internal_set_value_int(int64_t value) {
  if (!_internal_has_value_int()) {
    clear_datum();
    set_has_value_int();
  }
  _impl_.datum_.value_int_ = value;
}
inline int64_t Value::value_int() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Value.value_int)
  return _internal_value_int();
}
inline void Value::set_value_int(int64_t value) {
  _internal_set_value_int(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.value_int)
}

// float value_float = 3;
inline bool Value::_internal_has_value_float() const {
  return datum_case() == kValueFloat;
}
inline bool Value::has_value_float() const {
  return _internal_has_value_float();
}
inline void Value::set_has_value_float() {
  _impl_._oneof_case_[0] = kValueFloat;
}
inline void Value::clear_value_float() {
  if (_internal_has_value_float()) {
    _impl_.datum_.value_float_ = 0;
    clear_has_datum();
  }
}
inline float Value::_internal_value_float() const {
  if (_internal_has_value_float()) {
    return _impl_.datum_.value_float_;
  }
  return 0;
}
inline void Value::_internal_set_value_float(float value) {
  if (!_internal_has_value_float()) {
    clear_datum();
    set_has_value_float();
  }
  _impl_.datum_.value_float_ = value;
}
inline float Value::value_float() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Value.value_float)
  return _internal_value_float();
}
inline void Value::set_value_float(float value) {
  _internal_set_value_float(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.value_float)
}

// double value_double = 4;
inline bool Value::_internal_has_value_double() const {
  return datum_case() == kValueDouble;
}
inline bool Value::has_value_double() const {
  return _internal_has_value_double();
}
inline void Value::set_has_value_double() {
  _impl_._oneof_case_[0] = kValueDouble;
}
inline void Value::clear_value_double() {
  if (_internal_has_value_double()) {
    _impl_.datum_.value_double_ = 0;
    clear_has_datum();
  }
}
inline double Value::_internal_value_double() const {
  if (_internal_has_value_double()) {
    return _impl_.datum_.value_double_;
  }
  return 0;
}
inline void Value::_internal_set_value_double(double value) {
  if (!_internal_has_value_double()) {
    clear_datum();
    set_has_value_double();
  }
  _impl_.datum_.value_double_ = value;
}
inline double Value::value_double() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Value.value_double)
  return _internal_value_double();
}
inline void Value::set_value_double(double value) {
  _internal_set_value_double(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.value_double)
}

// string value_string = 5;
inline bool Value::_internal_has_value_string() const {
  return datum_case() == kValueString;
}
inline bool Value::has_value_string() const {
  return _internal_has_value_string();
}
inline void Value::set_has_value_string() {
  _impl_._oneof_case_[0] = kValueString;
}
inline void Value::clear_value_string() {
  if (_internal_has_value_string()) {
    _impl_.datum_.value_string_.Destroy();
    clear_has_datum();
  }
}
inline const std::string& Value::value_string() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Value.value_string)
  return _internal_value_string();
}
template <typename ArgT0, typename... ArgT>
inline void Value::set_value_string(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_value_string()) {
    clear_datum();
    set_has_value_string();
    _impl_.datum_.value_string_.InitDefault();
  }
  _impl_.datum_.value_string_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.value_string)
}
inline std::string* Value::mutable_value_string() {
  std::string* _s = _internal_mutable_value_string();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Value.value_string)
  return _s;
}
inline const std::string& Value::_internal_value_string() const {
  if (_internal_has_value_string()) {
    return _impl_.datum_.value_string_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_value_string(const std::string& value) {
  if (!_internal_has_value_string()) {
    clear_datum();
    set_has_value_string();
    _impl_.datum_.value_string_.InitDefault();
  }
  _impl_.datum_.value_string_.Set(value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_value_string() {
  if (!_internal_has_value_string()) {
    clear_datum();
    set_has_value_string();
    _impl_.datum_.value_string_.InitDefault();
  }
  return _impl_.datum_.value_string_.Mutable(      GetArenaForAllocation());
}
inline std::string* Value::release_value_string() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Value.value_string)
  if (_internal_has_value_string()) {
    clear_has_datum();
    return _impl_.datum_.value_string_.Release();
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_value_string(std::string* value_string) {
  if (has_datum()) {
    clear_datum();
  }
  if (value_string != nullptr) {
    set_has_value_string();
    _impl_.datum_.value_string_.InitAllocated(value_string, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Value.value_string)
}

// bytes value_bytes = 6;
inline bool Value::_internal_has_value_bytes() const {
  return datum_case() == kValueBytes;
}
inline bool Value::has_value_bytes() const {
  return _internal_has_value_bytes();
}
inline void Value::set_has_value_bytes() {
  _impl_._oneof_case_[0] = kValueBytes;
}
inline void Value::clear_value_bytes() {
  if (_internal_has_value_bytes()) {
    _impl_.datum_.value_bytes_.Destroy();
    clear_has_datum();
  }
}
inline const std::string& Value::value_bytes() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Value.value_bytes)
  return _internal_value_bytes();
}
template <typename ArgT0, typename... ArgT>
inline void Value::set_value_bytes(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_value_bytes()) {
    clear_datum();
    set_has_value_bytes();
    _impl_.datum_.value_bytes_.InitDefault();
  }
  _impl_.datum_.value_bytes_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Value.value_bytes)
}
inline std::string* Value::mutable_value_bytes() {
  std::string* _s = _internal_mutable_value_bytes();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Value.value_bytes)
  return _s;
}
inline const std::string& Value::_internal_value_bytes() const {
  if (_internal_has_value_bytes()) {
    return _impl_.datum_.value_bytes_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_value_bytes(const std::string& value) {
  if (!_internal_has_value_bytes()) {
    clear_datum();
    set_has_value_bytes();
    _impl_.datum_.value_bytes_.InitDefault();
  }
  _impl_.datum_.value_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_value_bytes() {
  if (!_internal_has_value_bytes()) {
    clear_datum();
    set_has_value_bytes();
    _impl_.datum_.value_bytes_.InitDefault();
  }
  return _impl_.datum_.value_bytes_.Mutable(      GetArenaForAllocation());
}
inline std::string* Value::release_value_bytes() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Value.value_bytes)
  if (_internal_has_value_bytes()) {
    clear_has_datum();
    return _impl_.datum_.value_bytes_.Release();
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_value_bytes(std::string* value_bytes) {
  if (has_datum()) {
    clear_datum();
  }
  if (value_bytes != nullptr) {
    set_has_value_bytes();
    _impl_.datum_.value_bytes_.InitAllocated(value_bytes, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Value.value_bytes)
}

inline bool Value::has_datum() const {
  return datum_case() != DATUM_NOT_SET;
}
inline void Value::clear_has_datum() {
  _impl_._oneof_case_[0] = DATUM_NOT_SET;
}
inline Value::DatumCase Value::datum_case() const {
  return Value::DatumCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Column

// string name = 1;
inline void Column::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Column::name() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Column.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Column::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Column.name)
}
inline std::string* Column::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Column.name)
  return _s;
}
inline const std::string& Column::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Column::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Column::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Column::release_name() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Column.name)
  return _impl_.name_.Release();
}
inline void Column::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Column.name)
}

// .OpenLogReplicator.pb.ColumnType type = 2;
inline void Column::clear_type() {
  _impl_.type_ = 0;
}
inline ::OpenLogReplicator::pb::ColumnType Column::_internal_type() const {
  return static_cast< ::OpenLogReplicator::pb::ColumnType >(_impl_.type_);
}
inline ::OpenLogReplicator::pb::ColumnType Column::type() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Column.type)
  return _internal_type();
}
inline void Column::_internal_set_type(::OpenLogReplicator::pb::ColumnType value) {
  
  _impl_.type_ = value;
}
inline void Column::set_type(::OpenLogReplicator::pb::ColumnType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Column.type)
}

// int32 length = 3;
inline void Column::clear_length() {
  _impl_.length_ = 0;
}
inline int32_t Column::_internal_length() const {
  return _impl_.length_;
}
inline int32_t Column::length() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Column.length)
  return _internal_length();
}
inline void Column::_internal_set_length(int32_t value) {
  
  _impl_.length_ = value;
}
inline void Column::set_length(int32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Column.length)
}

// int32 precision = 4;
inline void Column::clear_precision() {
  _impl_.precision_ = 0;
}
inline int32_t Column::_internal_precision() const {
  return _impl_.precision_;
}
inline int32_t Column::precision() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Column.precision)
  return _internal_precision();
}
inline void Column::_internal_set_precision(int32_t value) {
  
  _impl_.precision_ = value;
}
inline void Column::set_precision(int32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Column.precision)
}

// int32 scale = 5;
inline void Column::clear_scale() {
  _impl_.scale_ = 0;
}
inline int32_t Column::_internal_scale() const {
  return _impl_.scale_;
}
inline int32_t Column::scale() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Column.scale)
  return _internal_scale();
}
inline void Column::_internal_set_scale(int32_t value) {
  
  _impl_.scale_ = value;
}
inline void Column::set_scale(int32_t value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Column.scale)
}

// bool nullable = 6;
inline void Column::clear_nullable() {
  _impl_.nullable_ = false;
}
inline bool Column::_internal_nullable() const {
  return _impl_.nullable_;
}
inline bool Column::nullable() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Column.nullable)
  return _internal_nullable();
}
inline void Column::_internal_set_nullable(bool value) {
  
  _impl_.nullable_ = value;
}
inline void Column::set_nullable(bool value) {
  _internal_set_nullable(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Column.nullable)
}

// -------------------------------------------------------------------

// Schema

// string owner = 1;
inline void Schema::clear_owner() {
  _impl_.owner_.ClearToEmpty();
}
inline const std::string& Schema::owner() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Schema.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schema::set_owner(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Schema.owner)
}
inline std::string* Schema::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Schema.owner)
  return _s;
}
inline const std::string& Schema::_internal_owner() const {
  return _impl_.owner_.Get();
}
inline void Schema::_internal_set_owner(const std::string& value) {
  
  _impl_.owner_.Set(value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_owner() {
  
  return _impl_.owner_.Mutable(GetArenaForAllocation());
}
inline std::string* Schema::release_owner() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Schema.owner)
  return _impl_.owner_.Release();
}
inline void Schema::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  _impl_.owner_.SetAllocated(owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_.IsDefault()) {
    _impl_.owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Schema.owner)
}

// string name = 2;
inline void Schema::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Schema::name() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Schema.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schema::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Schema.name)
}
inline std::string* Schema::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Schema.name)
  return _s;
}
inline const std::string& Schema::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Schema::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Schema::release_name() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Schema.name)
  return _impl_.name_.Release();
}
inline void Schema::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Schema.name)
}

// uint32 obj = 3;
inline void Schema::clear_obj() {
  _impl_.obj_ = 0u;
}
inline uint32_t Schema::_internal_obj() const {
  return _impl_.obj_;
}
inline uint32_t Schema::obj() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Schema.obj)
  return _internal_obj();
}
inline void Schema::_internal_set_obj(uint32_t value) {
  
  _impl_.obj_ = value;
}
inline void Schema::set_obj(uint32_t value) {
  _internal_set_obj(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Schema.obj)
}

// uint64 tm = 4;
inline bool Schema::_internal_has_tm() const {
  return tm_val_case() == kTm;
}
inline bool Schema::has_tm() const {
  return _internal_has_tm();
}
inline void Schema::set_has_tm() {
  _impl_._oneof_case_[0] = kTm;
}
inline void Schema::clear_tm() {
  if (_internal_has_tm()) {
    _impl_.tm_val_.tm_ = uint64_t{0u};
    clear_has_tm_val();
  }
}
inline uint64_t Schema::_internal_tm() const {
  if (_internal_has_tm()) {
    return _impl_.tm_val_.tm_;
  }
  return uint64_t{0u};
}
inline void Schema::_internal_set_tm(uint64_t value) {
  if (!_internal_has_tm()) {
    clear_tm_val();
    set_has_tm();
  }
  _impl_.tm_val_.tm_ = value;
}
inline uint64_t Schema::tm() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Schema.tm)
  return _internal_tm();
}
inline void Schema::set_tm(uint64_t value) {
  _internal_set_tm(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Schema.tm)
}

// string tms = 5;
inline bool Schema::_internal_has_tms() const {
  return tm_val_case() == kTms;
}
inline bool Schema::has_tms() const {
  return _internal_has_tms();
}
inline void Schema::set_has_tms() {
  _impl_._oneof_case_[0] = kTms;
}
inline void Schema::clear_tms() {
  if (_internal_has_tms()) {
    _impl_.tm_val_.tms_.Destroy();
    clear_has_tm_val();
  }
}
inline const std::string& Schema::tms() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Schema.tms)
  return _internal_tms();
}
template <typename ArgT0, typename... ArgT>
inline void Schema::set_tms(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    _impl_.tm_val_.tms_.InitDefault();
  }
  _impl_.tm_val_.tms_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Schema.tms)
}
inline std::string* Schema::mutable_tms() {
  std::string* _s = _internal_mutable_tms();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Schema.tms)
  return _s;
}
inline const std::string& Schema::_internal_tms() const {
  if (_internal_has_tms()) {
    return _impl_.tm_val_.tms_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Schema::_internal_set_tms(const std::string& value) {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    _impl_.tm_val_.tms_.InitDefault();
  }
  _impl_.tm_val_.tms_.Set(value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_tms() {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    _impl_.tm_val_.tms_.InitDefault();
  }
  return _impl_.tm_val_.tms_.Mutable(      GetArenaForAllocation());
}
inline std::string* Schema::release_tms() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Schema.tms)
  if (_internal_has_tms()) {
    clear_has_tm_val();
    return _impl_.tm_val_.tms_.Release();
  } else {
    return nullptr;
  }
}
inline void Schema::set_allocated_tms(std::string* tms) {
  if (has_tm_val()) {
    clear_tm_val();
  }
  if (tms != nullptr) {
    set_has_tms();
    _impl_.tm_val_.tms_.InitAllocated(tms, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Schema.tms)
}

// repeated .OpenLogReplicator.pb.Column column = 6;
inline int Schema::_internal_column_size() const {
  return _impl_.column_.size();
}
inline int Schema::column_size() const {
  return _internal_column_size();
}
inline void Schema::clear_column() {
  _impl_.column_.Clear();
}
inline ::OpenLogReplicator::pb::Column* Schema::mutable_column(int index) {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Schema.column)
  return _impl_.column_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Column >*
Schema::mutable_column() {
  // @@protoc_insertion_point(field_mutable_list:OpenLogReplicator.pb.Schema.column)
  return &_impl_.column_;
}
inline const ::OpenLogReplicator::pb::Column& Schema::_internal_column(int index) const {
  return _impl_.column_.Get(index);
}
inline const ::OpenLogReplicator::pb::Column& Schema::column(int index) const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Schema.column)
  return _internal_column(index);
}
inline ::OpenLogReplicator::pb::Column* Schema::_internal_add_column() {
  return _impl_.column_.Add();
}
inline ::OpenLogReplicator::pb::Column* Schema::add_column() {
  ::OpenLogReplicator::pb::Column* _add = _internal_add_column();
  // @@protoc_insertion_point(field_add:OpenLogReplicator.pb.Schema.column)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Column >&
Schema::column() const {
  // @@protoc_insertion_point(field_list:OpenLogReplicator.pb.Schema.column)
  return _impl_.column_;
}

inline bool Schema::has_tm_val() const {
  return tm_val_case() != TM_VAL_NOT_SET;
}
inline void Schema::clear_has_tm_val() {
  _impl_._oneof_case_[0] = TM_VAL_NOT_SET;
}
inline Schema::TmValCase Schema::tm_val_case() const {
  return Schema::TmValCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Payload

// .OpenLogReplicator.pb.Op op = 1;
inline void Payload::clear_op() {
  _impl_.op_ = 0;
}
inline ::OpenLogReplicator::pb::Op Payload::_internal_op() const {
  return static_cast< ::OpenLogReplicator::pb::Op >(_impl_.op_);
}
inline ::OpenLogReplicator::pb::Op Payload::op() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.op)
  return _internal_op();
}
inline void Payload::_internal_set_op(::OpenLogReplicator::pb::Op value) {
  
  _impl_.op_ = value;
}
inline void Payload::set_op(::OpenLogReplicator::pb::Op value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Payload.op)
}

// .OpenLogReplicator.pb.Schema schema = 2;
inline bool Payload::_internal_has_schema() const {
  return this != internal_default_instance() && _impl_.schema_ != nullptr;
}
inline bool Payload::has_schema() const {
  return _internal_has_schema();
}
inline void Payload::clear_schema() {
  if (GetArenaForAllocation() == nullptr && _impl_.schema_ != nullptr) {
    delete _impl_.schema_;
  }
  _impl_.schema_ = nullptr;
}
inline const ::OpenLogReplicator::pb::Schema& Payload::_internal_schema() const {
  const ::OpenLogReplicator::pb::Schema* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::OpenLogReplicator::pb::Schema&>(
      ::OpenLogReplicator::pb::_Schema_default_instance_);
}
inline const ::OpenLogReplicator::pb::Schema& Payload::schema() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.schema)
  return _internal_schema();
}
inline void Payload::unsafe_arena_set_allocated_schema(
    ::OpenLogReplicator::pb::Schema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = schema;
  if (schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OpenLogReplicator.pb.Payload.schema)
}
inline ::OpenLogReplicator::pb::Schema* Payload::release_schema() {
  
  ::OpenLogReplicator::pb::Schema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OpenLogReplicator::pb::Schema* Payload::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Payload.schema)
  
  ::OpenLogReplicator::pb::Schema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::OpenLogReplicator::pb::Schema* Payload::_internal_mutable_schema() {
  
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::OpenLogReplicator::pb::Schema>(GetArenaForAllocation());
    _impl_.schema_ = p;
  }
  return _impl_.schema_;
}
inline ::OpenLogReplicator::pb::Schema* Payload::mutable_schema() {
  ::OpenLogReplicator::pb::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Payload.schema)
  return _msg;
}
inline void Payload::set_allocated_schema(::OpenLogReplicator::pb::Schema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Payload.schema)
}

// string rid = 3;
inline void Payload::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& Payload::rid() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payload::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Payload.rid)
}
inline std::string* Payload::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Payload.rid)
  return _s;
}
inline const std::string& Payload::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void Payload::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* Payload::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* Payload::release_rid() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Payload.rid)
  return _impl_.rid_.Release();
}
inline void Payload::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Payload.rid)
}

// repeated .OpenLogReplicator.pb.Value before = 4;
inline int Payload::_internal_before_size() const {
  return _impl_.before_.size();
}
inline int Payload::before_size() const {
  return _internal_before_size();
}
inline void Payload::clear_before() {
  _impl_.before_.Clear();
}
inline ::OpenLogReplicator::pb::Value* Payload::mutable_before(int index) {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Payload.before)
  return _impl_.before_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >*
Payload::mutable_before() {
  // @@protoc_insertion_point(field_mutable_list:OpenLogReplicator.pb.Payload.before)
  return &_impl_.before_;
}
inline const ::OpenLogReplicator::pb::Value& Payload::_internal_before(int index) const {
  return _impl_.before_.Get(index);
}
inline const ::OpenLogReplicator::pb::Value& Payload::before(int index) const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.before)
  return _internal_before(index);
}
inline ::OpenLogReplicator::pb::Value* Payload::_internal_add_before() {
  return _impl_.before_.Add();
}
inline ::OpenLogReplicator::pb::Value* Payload::add_before() {
  ::OpenLogReplicator::pb::Value* _add = _internal_add_before();
  // @@protoc_insertion_point(field_add:OpenLogReplicator.pb.Payload.before)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >&
Payload::before() const {
  // @@protoc_insertion_point(field_list:OpenLogReplicator.pb.Payload.before)
  return _impl_.before_;
}

// repeated .OpenLogReplicator.pb.Value after = 5;
inline int Payload::_internal_after_size() const {
  return _impl_.after_.size();
}
inline int Payload::after_size() const {
  return _internal_after_size();
}
inline void Payload::clear_after() {
  _impl_.after_.Clear();
}
inline ::OpenLogReplicator::pb::Value* Payload::mutable_after(int index) {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Payload.after)
  return _impl_.after_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >*
Payload::mutable_after() {
  // @@protoc_insertion_point(field_mutable_list:OpenLogReplicator.pb.Payload.after)
  return &_impl_.after_;
}
inline const ::OpenLogReplicator::pb::Value& Payload::_internal_after(int index) const {
  return _impl_.after_.Get(index);
}
inline const ::OpenLogReplicator::pb::Value& Payload::after(int index) const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.after)
  return _internal_after(index);
}
inline ::OpenLogReplicator::pb::Value* Payload::_internal_add_after() {
  return _impl_.after_.Add();
}
inline ::OpenLogReplicator::pb::Value* Payload::add_after() {
  ::OpenLogReplicator::pb::Value* _add = _internal_add_after();
  // @@protoc_insertion_point(field_add:OpenLogReplicator.pb.Payload.after)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Value >&
Payload::after() const {
  // @@protoc_insertion_point(field_list:OpenLogReplicator.pb.Payload.after)
  return _impl_.after_;
}

// string ddl = 6;
inline void Payload::clear_ddl() {
  _impl_.ddl_.ClearToEmpty();
}
inline const std::string& Payload::ddl() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.ddl)
  return _internal_ddl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payload::set_ddl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ddl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Payload.ddl)
}
inline std::string* Payload::mutable_ddl() {
  std::string* _s = _internal_mutable_ddl();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.Payload.ddl)
  return _s;
}
inline const std::string& Payload::_internal_ddl() const {
  return _impl_.ddl_.Get();
}
inline void Payload::_internal_set_ddl(const std::string& value) {
  
  _impl_.ddl_.Set(value, GetArenaForAllocation());
}
inline std::string* Payload::_internal_mutable_ddl() {
  
  return _impl_.ddl_.Mutable(GetArenaForAllocation());
}
inline std::string* Payload::release_ddl() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.Payload.ddl)
  return _impl_.ddl_.Release();
}
inline void Payload::set_allocated_ddl(std::string* ddl) {
  if (ddl != nullptr) {
    
  } else {
    
  }
  _impl_.ddl_.SetAllocated(ddl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ddl_.IsDefault()) {
    _impl_.ddl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.Payload.ddl)
}

// uint32 seq = 7;
inline void Payload::clear_seq() {
  _impl_.seq_ = 0u;
}
inline uint32_t Payload::_internal_seq() const {
  return _impl_.seq_;
}
inline uint32_t Payload::seq() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.seq)
  return _internal_seq();
}
inline void Payload::_internal_set_seq(uint32_t value) {
  
  _impl_.seq_ = value;
}
inline void Payload::set_seq(uint32_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Payload.seq)
}

// uint64 offset = 8;
inline void Payload::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t Payload::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t Payload::offset() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.offset)
  return _internal_offset();
}
inline void Payload::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void Payload::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Payload.offset)
}

// bool redo = 9;
inline void Payload::clear_redo() {
  _impl_.redo_ = false;
}
inline bool Payload::_internal_redo() const {
  return _impl_.redo_;
}
inline bool Payload::redo() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.redo)
  return _internal_redo();
}
inline void Payload::_internal_set_redo(bool value) {
  
  _impl_.redo_ = value;
}
inline void Payload::set_redo(bool value) {
  _internal_set_redo(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Payload.redo)
}

// uint64 num = 10;
inline void Payload::clear_num() {
  _impl_.num_ = uint64_t{0u};
}
inline uint64_t Payload::_internal_num() const {
  return _impl_.num_;
}
inline uint64_t Payload::num() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.Payload.num)
  return _internal_num();
}
inline void Payload::_internal_set_num(uint64_t value) {
  
  _impl_.num_ = value;
}
inline void Payload::set_num(uint64_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.Payload.num)
}

// -------------------------------------------------------------------

// SchemaRequest

// string mask = 1;
inline void SchemaRequest::clear_mask() {
  _impl_.mask_.ClearToEmpty();
}
inline const std::string& SchemaRequest::mask() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.SchemaRequest.mask)
  return _internal_mask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaRequest::set_mask(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mask_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.SchemaRequest.mask)
}
inline std::string* SchemaRequest::mutable_mask() {
  std::string* _s = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.SchemaRequest.mask)
  return _s;
}
inline const std::string& SchemaRequest::_internal_mask() const {
  return _impl_.mask_.Get();
}
inline void SchemaRequest::_internal_set_mask(const std::string& value) {
  
  _impl_.mask_.Set(value, GetArenaForAllocation());
}
inline std::string* SchemaRequest::_internal_mutable_mask() {
  
  return _impl_.mask_.Mutable(GetArenaForAllocation());
}
inline std::string* SchemaRequest::release_mask() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.SchemaRequest.mask)
  return _impl_.mask_.Release();
}
inline void SchemaRequest::set_allocated_mask(std::string* mask) {
  if (mask != nullptr) {
    
  } else {
    
  }
  _impl_.mask_.SetAllocated(mask, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mask_.IsDefault()) {
    _impl_.mask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.SchemaRequest.mask)
}

// string filter = 2;
inline void SchemaRequest::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& SchemaRequest::filter() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.SchemaRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.SchemaRequest.filter)
}
inline std::string* SchemaRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.SchemaRequest.filter)
  return _s;
}
inline const std::string& SchemaRequest::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void SchemaRequest::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* SchemaRequest::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* SchemaRequest::release_filter() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.SchemaRequest.filter)
  return _impl_.filter_.Release();
}
inline void SchemaRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.SchemaRequest.filter)
}

// -------------------------------------------------------------------

// RedoRequest

// .OpenLogReplicator.pb.RequestCode code = 1;
inline void RedoRequest::clear_code() {
  _impl_.code_ = 0;
}
inline ::OpenLogReplicator::pb::RequestCode RedoRequest::_internal_code() const {
  return static_cast< ::OpenLogReplicator::pb::RequestCode >(_impl_.code_);
}
inline ::OpenLogReplicator::pb::RequestCode RedoRequest::code() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.code)
  return _internal_code();
}
inline void RedoRequest::_internal_set_code(::OpenLogReplicator::pb::RequestCode value) {
  
  _impl_.code_ = value;
}
inline void RedoRequest::set_code(::OpenLogReplicator::pb::RequestCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.code)
}

// string database_name = 2;
inline void RedoRequest::clear_database_name() {
  _impl_.database_name_.ClearToEmpty();
}
inline const std::string& RedoRequest::database_name() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.database_name)
  return _internal_database_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RedoRequest::set_database_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.database_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.database_name)
}
inline std::string* RedoRequest::mutable_database_name() {
  std::string* _s = _internal_mutable_database_name();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoRequest.database_name)
  return _s;
}
inline const std::string& RedoRequest::_internal_database_name() const {
  return _impl_.database_name_.Get();
}
inline void RedoRequest::_internal_set_database_name(const std::string& value) {
  
  _impl_.database_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RedoRequest::_internal_mutable_database_name() {
  
  return _impl_.database_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RedoRequest::release_database_name() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.RedoRequest.database_name)
  return _impl_.database_name_.Release();
}
inline void RedoRequest::set_allocated_database_name(std::string* database_name) {
  if (database_name != nullptr) {
    
  } else {
    
  }
  _impl_.database_name_.SetAllocated(database_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_name_.IsDefault()) {
    _impl_.database_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.RedoRequest.database_name)
}

// uint64 scn = 3;
inline bool RedoRequest::_internal_has_scn() const {
  return tm_val_case() == kScn;
}
inline bool RedoRequest::has_scn() const {
  return _internal_has_scn();
}
inline void RedoRequest::set_has_scn() {
  _impl_._oneof_case_[0] = kScn;
}
inline void RedoRequest::clear_scn() {
  if (_internal_has_scn()) {
    _impl_.tm_val_.scn_ = uint64_t{0u};
    clear_has_tm_val();
  }
}
inline uint64_t RedoRequest::_internal_scn() const {
  if (_internal_has_scn()) {
    return _impl_.tm_val_.scn_;
  }
  return uint64_t{0u};
}
inline void RedoRequest::_internal_set_scn(uint64_t value) {
  if (!_internal_has_scn()) {
    clear_tm_val();
    set_has_scn();
  }
  _impl_.tm_val_.scn_ = value;
}
inline uint64_t RedoRequest::scn() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.scn)
  return _internal_scn();
}
inline void RedoRequest::set_scn(uint64_t value) {
  _internal_set_scn(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.scn)
}

// string tms = 4;
inline bool RedoRequest::_internal_has_tms() const {
  return tm_val_case() == kTms;
}
inline bool RedoRequest::has_tms() const {
  return _internal_has_tms();
}
inline void RedoRequest::set_has_tms() {
  _impl_._oneof_case_[0] = kTms;
}
inline void RedoRequest::clear_tms() {
  if (_internal_has_tms()) {
    _impl_.tm_val_.tms_.Destroy();
    clear_has_tm_val();
  }
}
inline const std::string& RedoRequest::tms() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.tms)
  return _internal_tms();
}
template <typename ArgT0, typename... ArgT>
inline void RedoRequest::set_tms(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    _impl_.tm_val_.tms_.InitDefault();
  }
  _impl_.tm_val_.tms_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.tms)
}
inline std::string* RedoRequest::mutable_tms() {
  std::string* _s = _internal_mutable_tms();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoRequest.tms)
  return _s;
}
inline const std::string& RedoRequest::_internal_tms() const {
  if (_internal_has_tms()) {
    return _impl_.tm_val_.tms_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RedoRequest::_internal_set_tms(const std::string& value) {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    _impl_.tm_val_.tms_.InitDefault();
  }
  _impl_.tm_val_.tms_.Set(value, GetArenaForAllocation());
}
inline std::string* RedoRequest::_internal_mutable_tms() {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    _impl_.tm_val_.tms_.InitDefault();
  }
  return _impl_.tm_val_.tms_.Mutable(      GetArenaForAllocation());
}
inline std::string* RedoRequest::release_tms() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.RedoRequest.tms)
  if (_internal_has_tms()) {
    clear_has_tm_val();
    return _impl_.tm_val_.tms_.Release();
  } else {
    return nullptr;
  }
}
inline void RedoRequest::set_allocated_tms(std::string* tms) {
  if (has_tm_val()) {
    clear_tm_val();
  }
  if (tms != nullptr) {
    set_has_tms();
    _impl_.tm_val_.tms_.InitAllocated(tms, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.RedoRequest.tms)
}

// int64 tm_rel = 5;
inline bool RedoRequest::_internal_has_tm_rel() const {
  return tm_val_case() == kTmRel;
}
inline bool RedoRequest::has_tm_rel() const {
  return _internal_has_tm_rel();
}
inline void RedoRequest::set_has_tm_rel() {
  _impl_._oneof_case_[0] = kTmRel;
}
inline void RedoRequest::clear_tm_rel() {
  if (_internal_has_tm_rel()) {
    _impl_.tm_val_.tm_rel_ = int64_t{0};
    clear_has_tm_val();
  }
}
inline int64_t RedoRequest::_internal_tm_rel() const {
  if (_internal_has_tm_rel()) {
    return _impl_.tm_val_.tm_rel_;
  }
  return int64_t{0};
}
inline void RedoRequest::_internal_set_tm_rel(int64_t value) {
  if (!_internal_has_tm_rel()) {
    clear_tm_val();
    set_has_tm_rel();
  }
  _impl_.tm_val_.tm_rel_ = value;
}
inline int64_t RedoRequest::tm_rel() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.tm_rel)
  return _internal_tm_rel();
}
inline void RedoRequest::set_tm_rel(int64_t value) {
  _internal_set_tm_rel(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.tm_rel)
}

// optional uint64 seq = 6;
inline bool RedoRequest::_internal_has_seq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RedoRequest::has_seq() const {
  return _internal_has_seq();
}
inline void RedoRequest::clear_seq() {
  _impl_.seq_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t RedoRequest::_internal_seq() const {
  return _impl_.seq_;
}
inline uint64_t RedoRequest::seq() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.seq)
  return _internal_seq();
}
inline void RedoRequest::_internal_set_seq(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seq_ = value;
}
inline void RedoRequest::set_seq(uint64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.seq)
}

// repeated .OpenLogReplicator.pb.SchemaRequest schema = 7;
inline int RedoRequest::_internal_schema_size() const {
  return _impl_.schema_.size();
}
inline int RedoRequest::schema_size() const {
  return _internal_schema_size();
}
inline void RedoRequest::clear_schema() {
  _impl_.schema_.Clear();
}
inline ::OpenLogReplicator::pb::SchemaRequest* RedoRequest::mutable_schema(int index) {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoRequest.schema)
  return _impl_.schema_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::SchemaRequest >*
RedoRequest::mutable_schema() {
  // @@protoc_insertion_point(field_mutable_list:OpenLogReplicator.pb.RedoRequest.schema)
  return &_impl_.schema_;
}
inline const ::OpenLogReplicator::pb::SchemaRequest& RedoRequest::_internal_schema(int index) const {
  return _impl_.schema_.Get(index);
}
inline const ::OpenLogReplicator::pb::SchemaRequest& RedoRequest::schema(int index) const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.schema)
  return _internal_schema(index);
}
inline ::OpenLogReplicator::pb::SchemaRequest* RedoRequest::_internal_add_schema() {
  return _impl_.schema_.Add();
}
inline ::OpenLogReplicator::pb::SchemaRequest* RedoRequest::add_schema() {
  ::OpenLogReplicator::pb::SchemaRequest* _add = _internal_add_schema();
  // @@protoc_insertion_point(field_add:OpenLogReplicator.pb.RedoRequest.schema)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::SchemaRequest >&
RedoRequest::schema() const {
  // @@protoc_insertion_point(field_list:OpenLogReplicator.pb.RedoRequest.schema)
  return _impl_.schema_;
}

// optional uint64 c_scn = 8;
inline bool RedoRequest::_internal_has_c_scn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RedoRequest::has_c_scn() const {
  return _internal_has_c_scn();
}
inline void RedoRequest::clear_c_scn() {
  _impl_.c_scn_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t RedoRequest::_internal_c_scn() const {
  return _impl_.c_scn_;
}
inline uint64_t RedoRequest::c_scn() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.c_scn)
  return _internal_c_scn();
}
inline void RedoRequest::_internal_set_c_scn(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.c_scn_ = value;
}
inline void RedoRequest::set_c_scn(uint64_t value) {
  _internal_set_c_scn(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.c_scn)
}

// optional uint64 c_idx = 9;
inline bool RedoRequest::_internal_has_c_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RedoRequest::has_c_idx() const {
  return _internal_has_c_idx();
}
inline void RedoRequest::clear_c_idx() {
  _impl_.c_idx_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t RedoRequest::_internal_c_idx() const {
  return _impl_.c_idx_;
}
inline uint64_t RedoRequest::c_idx() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoRequest.c_idx)
  return _internal_c_idx();
}
inline void RedoRequest::_internal_set_c_idx(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.c_idx_ = value;
}
inline void RedoRequest::set_c_idx(uint64_t value) {
  _internal_set_c_idx(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoRequest.c_idx)
}

inline bool RedoRequest::has_tm_val() const {
  return tm_val_case() != TM_VAL_NOT_SET;
}
inline void RedoRequest::clear_has_tm_val() {
  _impl_._oneof_case_[0] = TM_VAL_NOT_SET;
}
inline RedoRequest::TmValCase RedoRequest::tm_val_case() const {
  return RedoRequest::TmValCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RedoResponse

// .OpenLogReplicator.pb.ResponseCode code = 1;
inline void RedoResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::OpenLogReplicator::pb::ResponseCode RedoResponse::_internal_code() const {
  return static_cast< ::OpenLogReplicator::pb::ResponseCode >(_impl_.code_);
}
inline ::OpenLogReplicator::pb::ResponseCode RedoResponse::code() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.code)
  return _internal_code();
}
inline void RedoResponse::_internal_set_code(::OpenLogReplicator::pb::ResponseCode value) {
  
  _impl_.code_ = value;
}
inline void RedoResponse::set_code(::OpenLogReplicator::pb::ResponseCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.code)
}

// uint64 scn = 2;
inline bool RedoResponse::_internal_has_scn() const {
  return scn_val_case() == kScn;
}
inline bool RedoResponse::has_scn() const {
  return _internal_has_scn();
}
inline void RedoResponse::set_has_scn() {
  _impl_._oneof_case_[0] = kScn;
}
inline void RedoResponse::clear_scn() {
  if (_internal_has_scn()) {
    _impl_.scn_val_.scn_ = uint64_t{0u};
    clear_has_scn_val();
  }
}
inline uint64_t RedoResponse::_internal_scn() const {
  if (_internal_has_scn()) {
    return _impl_.scn_val_.scn_;
  }
  return uint64_t{0u};
}
inline void RedoResponse::_internal_set_scn(uint64_t value) {
  if (!_internal_has_scn()) {
    clear_scn_val();
    set_has_scn();
  }
  _impl_.scn_val_.scn_ = value;
}
inline uint64_t RedoResponse::scn() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.scn)
  return _internal_scn();
}
inline void RedoResponse::set_scn(uint64_t value) {
  _internal_set_scn(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.scn)
}

// string scns = 3;
inline bool RedoResponse::_internal_has_scns() const {
  return scn_val_case() == kScns;
}
inline bool RedoResponse::has_scns() const {
  return _internal_has_scns();
}
inline void RedoResponse::set_has_scns() {
  _impl_._oneof_case_[0] = kScns;
}
inline void RedoResponse::clear_scns() {
  if (_internal_has_scns()) {
    _impl_.scn_val_.scns_.Destroy();
    clear_has_scn_val();
  }
}
inline const std::string& RedoResponse::scns() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.scns)
  return _internal_scns();
}
template <typename ArgT0, typename... ArgT>
inline void RedoResponse::set_scns(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_scns()) {
    clear_scn_val();
    set_has_scns();
    _impl_.scn_val_.scns_.InitDefault();
  }
  _impl_.scn_val_.scns_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.scns)
}
inline std::string* RedoResponse::mutable_scns() {
  std::string* _s = _internal_mutable_scns();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoResponse.scns)
  return _s;
}
inline const std::string& RedoResponse::_internal_scns() const {
  if (_internal_has_scns()) {
    return _impl_.scn_val_.scns_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RedoResponse::_internal_set_scns(const std::string& value) {
  if (!_internal_has_scns()) {
    clear_scn_val();
    set_has_scns();
    _impl_.scn_val_.scns_.InitDefault();
  }
  _impl_.scn_val_.scns_.Set(value, GetArenaForAllocation());
}
inline std::string* RedoResponse::_internal_mutable_scns() {
  if (!_internal_has_scns()) {
    clear_scn_val();
    set_has_scns();
    _impl_.scn_val_.scns_.InitDefault();
  }
  return _impl_.scn_val_.scns_.Mutable(      GetArenaForAllocation());
}
inline std::string* RedoResponse::release_scns() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.RedoResponse.scns)
  if (_internal_has_scns()) {
    clear_has_scn_val();
    return _impl_.scn_val_.scns_.Release();
  } else {
    return nullptr;
  }
}
inline void RedoResponse::set_allocated_scns(std::string* scns) {
  if (has_scn_val()) {
    clear_scn_val();
  }
  if (scns != nullptr) {
    set_has_scns();
    _impl_.scn_val_.scns_.InitAllocated(scns, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.RedoResponse.scns)
}

// uint64 tm = 4;
inline bool RedoResponse::_internal_has_tm() const {
  return tm_val_case() == kTm;
}
inline bool RedoResponse::has_tm() const {
  return _internal_has_tm();
}
inline void RedoResponse::set_has_tm() {
  _impl_._oneof_case_[1] = kTm;
}
inline void RedoResponse::clear_tm() {
  if (_internal_has_tm()) {
    _impl_.tm_val_.tm_ = uint64_t{0u};
    clear_has_tm_val();
  }
}
inline uint64_t RedoResponse::_internal_tm() const {
  if (_internal_has_tm()) {
    return _impl_.tm_val_.tm_;
  }
  return uint64_t{0u};
}
inline void RedoResponse::_internal_set_tm(uint64_t value) {
  if (!_internal_has_tm()) {
    clear_tm_val();
    set_has_tm();
  }
  _impl_.tm_val_.tm_ = value;
}
inline uint64_t RedoResponse::tm() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.tm)
  return _internal_tm();
}
inline void RedoResponse::set_tm(uint64_t value) {
  _internal_set_tm(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.tm)
}

// string tms = 5;
inline bool RedoResponse::_internal_has_tms() const {
  return tm_val_case() == kTms;
}
inline bool RedoResponse::has_tms() const {
  return _internal_has_tms();
}
inline void RedoResponse::set_has_tms() {
  _impl_._oneof_case_[1] = kTms;
}
inline void RedoResponse::clear_tms() {
  if (_internal_has_tms()) {
    _impl_.tm_val_.tms_.Destroy();
    clear_has_tm_val();
  }
}
inline const std::string& RedoResponse::tms() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.tms)
  return _internal_tms();
}
template <typename ArgT0, typename... ArgT>
inline void RedoResponse::set_tms(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    _impl_.tm_val_.tms_.InitDefault();
  }
  _impl_.tm_val_.tms_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.tms)
}
inline std::string* RedoResponse::mutable_tms() {
  std::string* _s = _internal_mutable_tms();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoResponse.tms)
  return _s;
}
inline const std::string& RedoResponse::_internal_tms() const {
  if (_internal_has_tms()) {
    return _impl_.tm_val_.tms_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RedoResponse::_internal_set_tms(const std::string& value) {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    _impl_.tm_val_.tms_.InitDefault();
  }
  _impl_.tm_val_.tms_.Set(value, GetArenaForAllocation());
}
inline std::string* RedoResponse::_internal_mutable_tms() {
  if (!_internal_has_tms()) {
    clear_tm_val();
    set_has_tms();
    _impl_.tm_val_.tms_.InitDefault();
  }
  return _impl_.tm_val_.tms_.Mutable(      GetArenaForAllocation());
}
inline std::string* RedoResponse::release_tms() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.RedoResponse.tms)
  if (_internal_has_tms()) {
    clear_has_tm_val();
    return _impl_.tm_val_.tms_.Release();
  } else {
    return nullptr;
  }
}
inline void RedoResponse::set_allocated_tms(std::string* tms) {
  if (has_tm_val()) {
    clear_tm_val();
  }
  if (tms != nullptr) {
    set_has_tms();
    _impl_.tm_val_.tms_.InitAllocated(tms, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.RedoResponse.tms)
}

// string xid = 6;
inline bool RedoResponse::_internal_has_xid() const {
  return xid_val_case() == kXid;
}
inline bool RedoResponse::has_xid() const {
  return _internal_has_xid();
}
inline void RedoResponse::set_has_xid() {
  _impl_._oneof_case_[2] = kXid;
}
inline void RedoResponse::clear_xid() {
  if (_internal_has_xid()) {
    _impl_.xid_val_.xid_.Destroy();
    clear_has_xid_val();
  }
}
inline const std::string& RedoResponse::xid() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.xid)
  return _internal_xid();
}
template <typename ArgT0, typename... ArgT>
inline void RedoResponse::set_xid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_xid()) {
    clear_xid_val();
    set_has_xid();
    _impl_.xid_val_.xid_.InitDefault();
  }
  _impl_.xid_val_.xid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.xid)
}
inline std::string* RedoResponse::mutable_xid() {
  std::string* _s = _internal_mutable_xid();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoResponse.xid)
  return _s;
}
inline const std::string& RedoResponse::_internal_xid() const {
  if (_internal_has_xid()) {
    return _impl_.xid_val_.xid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RedoResponse::_internal_set_xid(const std::string& value) {
  if (!_internal_has_xid()) {
    clear_xid_val();
    set_has_xid();
    _impl_.xid_val_.xid_.InitDefault();
  }
  _impl_.xid_val_.xid_.Set(value, GetArenaForAllocation());
}
inline std::string* RedoResponse::_internal_mutable_xid() {
  if (!_internal_has_xid()) {
    clear_xid_val();
    set_has_xid();
    _impl_.xid_val_.xid_.InitDefault();
  }
  return _impl_.xid_val_.xid_.Mutable(      GetArenaForAllocation());
}
inline std::string* RedoResponse::release_xid() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.RedoResponse.xid)
  if (_internal_has_xid()) {
    clear_has_xid_val();
    return _impl_.xid_val_.xid_.Release();
  } else {
    return nullptr;
  }
}
inline void RedoResponse::set_allocated_xid(std::string* xid) {
  if (has_xid_val()) {
    clear_xid_val();
  }
  if (xid != nullptr) {
    set_has_xid();
    _impl_.xid_val_.xid_.InitAllocated(xid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.RedoResponse.xid)
}

// uint64 xidn = 7;
inline bool RedoResponse::_internal_has_xidn() const {
  return xid_val_case() == kXidn;
}
inline bool RedoResponse::has_xidn() const {
  return _internal_has_xidn();
}
inline void RedoResponse::set_has_xidn() {
  _impl_._oneof_case_[2] = kXidn;
}
inline void RedoResponse::clear_xidn() {
  if (_internal_has_xidn()) {
    _impl_.xid_val_.xidn_ = uint64_t{0u};
    clear_has_xid_val();
  }
}
inline uint64_t RedoResponse::_internal_xidn() const {
  if (_internal_has_xidn()) {
    return _impl_.xid_val_.xidn_;
  }
  return uint64_t{0u};
}
inline void RedoResponse::_internal_set_xidn(uint64_t value) {
  if (!_internal_has_xidn()) {
    clear_xid_val();
    set_has_xidn();
  }
  _impl_.xid_val_.xidn_ = value;
}
inline uint64_t RedoResponse::xidn() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.xidn)
  return _internal_xidn();
}
inline void RedoResponse::set_xidn(uint64_t value) {
  _internal_set_xidn(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.xidn)
}

// string db = 8;
inline void RedoResponse::clear_db() {
  _impl_.db_.ClearToEmpty();
}
inline const std::string& RedoResponse::db() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.db)
  return _internal_db();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RedoResponse::set_db(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.db)
}
inline std::string* RedoResponse::mutable_db() {
  std::string* _s = _internal_mutable_db();
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoResponse.db)
  return _s;
}
inline const std::string& RedoResponse::_internal_db() const {
  return _impl_.db_.Get();
}
inline void RedoResponse::_internal_set_db(const std::string& value) {
  
  _impl_.db_.Set(value, GetArenaForAllocation());
}
inline std::string* RedoResponse::_internal_mutable_db() {
  
  return _impl_.db_.Mutable(GetArenaForAllocation());
}
inline std::string* RedoResponse::release_db() {
  // @@protoc_insertion_point(field_release:OpenLogReplicator.pb.RedoResponse.db)
  return _impl_.db_.Release();
}
inline void RedoResponse::set_allocated_db(std::string* db) {
  if (db != nullptr) {
    
  } else {
    
  }
  _impl_.db_.SetAllocated(db, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_.IsDefault()) {
    _impl_.db_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OpenLogReplicator.pb.RedoResponse.db)
}

// repeated .OpenLogReplicator.pb.Payload payload = 9;
inline int RedoResponse::_internal_payload_size() const {
  return _impl_.payload_.size();
}
inline int RedoResponse::payload_size() const {
  return _internal_payload_size();
}
inline void RedoResponse::clear_payload() {
  _impl_.payload_.Clear();
}
inline ::OpenLogReplicator::pb::Payload* RedoResponse::mutable_payload(int index) {
  // @@protoc_insertion_point(field_mutable:OpenLogReplicator.pb.RedoResponse.payload)
  return _impl_.payload_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Payload >*
RedoResponse::mutable_payload() {
  // @@protoc_insertion_point(field_mutable_list:OpenLogReplicator.pb.RedoResponse.payload)
  return &_impl_.payload_;
}
inline const ::OpenLogReplicator::pb::Payload& RedoResponse::_internal_payload(int index) const {
  return _impl_.payload_.Get(index);
}
inline const ::OpenLogReplicator::pb::Payload& RedoResponse::payload(int index) const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.payload)
  return _internal_payload(index);
}
inline ::OpenLogReplicator::pb::Payload* RedoResponse::_internal_add_payload() {
  return _impl_.payload_.Add();
}
inline ::OpenLogReplicator::pb::Payload* RedoResponse::add_payload() {
  ::OpenLogReplicator::pb::Payload* _add = _internal_add_payload();
  // @@protoc_insertion_point(field_add:OpenLogReplicator.pb.RedoResponse.payload)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenLogReplicator::pb::Payload >&
RedoResponse::payload() const {
  // @@protoc_insertion_point(field_list:OpenLogReplicator.pb.RedoResponse.payload)
  return _impl_.payload_;
}

// uint64 c_scn = 10;
inline void RedoResponse::clear_c_scn() {
  _impl_.c_scn_ = uint64_t{0u};
}
inline uint64_t RedoResponse::_internal_c_scn() const {
  return _impl_.c_scn_;
}
inline uint64_t RedoResponse::c_scn() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.c_scn)
  return _internal_c_scn();
}
inline void RedoResponse::_internal_set_c_scn(uint64_t value) {
  
  _impl_.c_scn_ = value;
}
inline void RedoResponse::set_c_scn(uint64_t value) {
  _internal_set_c_scn(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.c_scn)
}

// uint64 c_idx = 11;
inline void RedoResponse::clear_c_idx() {
  _impl_.c_idx_ = uint64_t{0u};
}
inline uint64_t RedoResponse::_internal_c_idx() const {
  return _impl_.c_idx_;
}
inline uint64_t RedoResponse::c_idx() const {
  // @@protoc_insertion_point(field_get:OpenLogReplicator.pb.RedoResponse.c_idx)
  return _internal_c_idx();
}
inline void RedoResponse::_internal_set_c_idx(uint64_t value) {
  
  _impl_.c_idx_ = value;
}
inline void RedoResponse::set_c_idx(uint64_t value) {
  _internal_set_c_idx(value);
  // @@protoc_insertion_point(field_set:OpenLogReplicator.pb.RedoResponse.c_idx)
}

// map<string, string> attributes = 12;
inline int RedoResponse::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int RedoResponse::attributes_size() const {
  return _internal_attributes_size();
}
inline void RedoResponse::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RedoResponse::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RedoResponse::attributes() const {
  // @@protoc_insertion_point(field_map:OpenLogReplicator.pb.RedoResponse.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RedoResponse::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RedoResponse::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:OpenLogReplicator.pb.RedoResponse.attributes)
  return _internal_mutable_attributes();
}

inline bool RedoResponse::has_scn_val() const {
  return scn_val_case() != SCN_VAL_NOT_SET;
}
inline void RedoResponse::clear_has_scn_val() {
  _impl_._oneof_case_[0] = SCN_VAL_NOT_SET;
}
inline bool RedoResponse::has_tm_val() const {
  return tm_val_case() != TM_VAL_NOT_SET;
}
inline void RedoResponse::clear_has_tm_val() {
  _impl_._oneof_case_[1] = TM_VAL_NOT_SET;
}
inline bool RedoResponse::has_xid_val() const {
  return xid_val_case() != XID_VAL_NOT_SET;
}
inline void RedoResponse::clear_has_xid_val() {
  _impl_._oneof_case_[2] = XID_VAL_NOT_SET;
}
inline RedoResponse::ScnValCase RedoResponse::scn_val_case() const {
  return RedoResponse::ScnValCase(_impl_._oneof_case_[0]);
}
inline RedoResponse::TmValCase RedoResponse::tm_val_case() const {
  return RedoResponse::TmValCase(_impl_._oneof_case_[1]);
}
inline RedoResponse::XidValCase RedoResponse::xid_val_case() const {
  return RedoResponse::XidValCase(_impl_._oneof_case_[2]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace OpenLogReplicator

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::OpenLogReplicator::pb::Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenLogReplicator::pb::Op>() {
  return ::OpenLogReplicator::pb::Op_descriptor();
}
template <> struct is_proto_enum< ::OpenLogReplicator::pb::ColumnType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenLogReplicator::pb::ColumnType>() {
  return ::OpenLogReplicator::pb::ColumnType_descriptor();
}
template <> struct is_proto_enum< ::OpenLogReplicator::pb::RequestCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenLogReplicator::pb::RequestCode>() {
  return ::OpenLogReplicator::pb::RequestCode_descriptor();
}
template <> struct is_proto_enum< ::OpenLogReplicator::pb::ResponseCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenLogReplicator::pb::ResponseCode>() {
  return ::OpenLogReplicator::pb::ResponseCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_OraProtoBuf_2eproto
